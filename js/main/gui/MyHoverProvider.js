import { Klass, Interface } from "../../compiler/types/Class.js";
import { Method, Attribute, PrimitiveType } from "../../compiler/types/Types.js";
import { getDeclarationAsString, getGenericParameterDefinition } from "../../compiler/types/DeclarationHelper.js";
import { InterpreterState } from "../../interpreter/Interpreter.js";
export class MyHoverProvider {
    constructor(editor) {
        this.editor = editor;
    }
    provideHover(model, position, token) {
        var _a, _b;
        let selection = this.editor.editor.getSelection();
        // if cursor is inside current selection then don't show hover, because editor.onDidChangeCursorPosition evaluates selected Text 
        // (see class Editor).
        if (selection != null) {
            if (selection.startLineNumber != selection.endLineNumber || selection.startColumn != selection.endColumn) {
                if ((selection.startLineNumber < position.lineNumber || selection.startLineNumber == position.lineNumber && selection.startColumn <= position.column) &&
                    (selection.endLineNumber > position.lineNumber || selection.endLineNumber == position.lineNumber && selection.endColumn >= position.column)) {
                    return;
                }
            }
        }
        let module = (_a = this.editor.main.getCurrentWorkspace()) === null || _a === void 0 ? void 0 : _a.getModuleByMonacoModel(model);
        if (module == null) {
            return null;
        }
        for (let errorList of module.errors) {
            for (let error of errorList) {
                if (error.position.line == position.lineNumber &&
                    error.position.column <= position.column &&
                    error.position.column + error.position.length >= position.column) {
                    return null; // Show error-tooltip and don't show hover-tooltip
                }
            }
        }
        let element = module.getElementAtPosition(position.lineNumber, position.column);
        let declarationAsString = "";
        if (element != null && element.identifier != "var") {
            if (element instanceof Klass || element instanceof Method || element instanceof Interface
                || element instanceof Attribute) {
                declarationAsString = getDeclarationAsString(element);
            }
            else if (element instanceof PrimitiveType) {
                declarationAsString = "```\n" + element.identifier + "\n```  \nprimitiver Datentyp: " + element.description + "";
                return {
                    range: null,
                    contents: [{ value: declarationAsString }],
                };
            }
            else {
                // Variable
                let typeIdentifier = (_b = element === null || element === void 0 ? void 0 : element.type) === null || _b === void 0 ? void 0 : _b.identifier;
                if ((element === null || element === void 0 ? void 0 : element.type) instanceof Klass || (element === null || element === void 0 ? void 0 : element.type) instanceof Interface) {
                    typeIdentifier += " " + getGenericParameterDefinition(element.type);
                }
                if (typeIdentifier == null) {
                    typeIdentifier = "";
                }
                else {
                    typeIdentifier += " ";
                }
                declarationAsString = typeIdentifier + (element === null || element === void 0 ? void 0 : element.identifier);
            }
        }
        else {
            let word = this.getWordUnderCursor(model, position);
            let desc = MyHoverProvider.keywordDescriptions[word];
            if (desc != null) {
                return {
                    range: null,
                    contents: [{ value: desc }],
                };
            }
        }
        let state = this.editor.main.getInterpreter().state;
        let value = null;
        if (state == InterpreterState.paused) {
            let evaluator = this.editor.main.getCurrentWorkspace().evaluator;
            let identifier = this.widenDeclaration(model, position, element === null || element === void 0 ? void 0 : element.identifier);
            if (identifier == null) {
                return null;
            }
            let result = evaluator.evaluate(identifier);
            if (result.error == null && result.value != null) {
                value = result.value.type.debugOutput(result.value);
                declarationAsString = identifier;
            }
        }
        let contents = [];
        if (value == null && declarationAsString.length == 0) {
            return null;
        }
        if (value != null) {
            if (value.length + declarationAsString.length > 40) {
                contents.push({ value: '```\n' + declarationAsString + ' ==\n```' });
                contents.push({ value: '```\n' + value.replace(/&nbsp;/g, " ") + '\n```' });
            }
            else {
                contents.push({ value: '```\n' + declarationAsString + " == " + value.replace(/&nbsp;/g, " ") + '\n```' });
            }
        }
        else {
            contents.push({ value: '```\n' + declarationAsString + '\n```' });
        }
        let range = null;
        return {
            range: range,
            contents: contents,
        };
    }
    getWordUnderCursor(model, position) {
        let pos = model.getValueLengthInRange({
            startColumn: 0,
            startLineNumber: 0,
            endLineNumber: position.lineNumber,
            endColumn: position.column
        });
        let text = model.getValue();
        let word = "";
        let end = pos;
        while (end < text.length && this.isInsideIdentifierOrArrayDescriptor(text.charAt(end))) {
            end++;
        }
        let begin = pos;
        while (begin > 0 && this.isInsideIdentifierOrArrayDescriptor(text.charAt(begin - 1))) {
            begin--;
        }
        if (end - begin > 1) {
            word = text.substring(begin, end);
        }
        else {
            end = pos;
            while (end < text.length && this.isInsideOperator(text.charAt(end))) {
                end++;
            }
            begin = pos;
            while (begin > 0 && this.isInsideOperator(text.charAt(begin - 1))) {
                begin--;
            }
            if (end - begin > 0) {
                word = text.substring(begin, end);
            }
        }
        return word;
    }
    widenDeclaration(model, position, identifier) {
        let pos = model.getValueLengthInRange({
            startColumn: 0,
            startLineNumber: 0,
            endLineNumber: position.lineNumber,
            endColumn: position.column
        });
        let text = model.getValue();
        let end = pos;
        while (end < text.length && this.isInsideIdentifierOrArrayDescriptor(text.charAt(end))) {
            end++;
        }
        let begin = pos;
        while (begin > 0 && this.isInsideIdentifierChain(text.charAt(begin - 1))) {
            begin--;
        }
        let lenght = (identifier === null || identifier === void 0 ? void 0 : identifier.length) == null ? 1 : identifier.length;
        if (end - begin > length) {
            return text.substring(begin, end);
        }
        return identifier;
    }
    isInsideIdentifierChain(t) {
        return t.toLocaleLowerCase().match(/[a-z0-9äöüß_\[\]\.]/i);
    }
    isInsideOperator(t) {
        return t.toLocaleLowerCase().match(/[!%<>=\+\-\*\/]/i);
    }
    isInsideIdentifierOrArrayDescriptor(t) {
        return t.toLocaleLowerCase().match(/[a-z0-9äöüß\[\]]/i);
    }
}
MyHoverProvider.keywordDescriptions = {
    "print": "Die Anweisung ```print``` gibt eine Zeichenkette aus.",
    "new": "Das Schlüsselwort ```new``` bewirkt die Instanzierung (\"Erschaffung\") eines neuen Objektes einer Klasse.",
    "println": "Die Anweisung ```println``` gibt eine Zeichenkette gefolgt von einem Zeilenumbruch aus.",
    "while": "```\nwhile (Bedingung) {Anweisungen}\n```  \nbewirkt die Wiederholung der Anweisungen solange ```Bedingung == true``` ist.",
    "for": "```\nfor(Startanweisung;Solange-Bedingung;Nach_jeder_Wiederholung){Anweisungen}\n```  \n"
        + "führt zunächst die Startanweisung aus und wiederholt dann die Anweisungen solange ```Bedingung == true``` ist. Am Ende jeder wiederholung wird Nach_jeder_Wiederholung ausgeführt.",
    "if": "```\nif(Bedingung){Anweisungen_1} else {Anweisungen_2}\n```  \nwertet die Bedingung aus und führt Anweisungen_1 nur dann aus, wenn die Bedingung ```true``` ergibt, Anweisungen_2 nur dann, wenn die Bedingung ```false``` ergibt.  \nDer ```else```-Teil kann auch weggelassen werden.",
    "else": "```\nif(Bedingung){Anweisungen_1} else {Anweisungen_2}\n```  \nwertet die Bedingung aus und führt Anweisungen_1 nur dann aus, wenn die Bedingung ```true``` ergibt, Anweisungen_2 nur dann, wenn die Bedingung ```false``` ergibt.",
    "switch": "```\nswitch(Selektor){ case Wert_1: Anweisungen_1; break; case Wert_2: Anweisungen_2; break; default: Default-Anweisungen } \n```  \nwertet den Selektor-Term aus und führt abhängig vom Termwert Anweisungen_1, Anweisungen_2, ... aus. Entspricht der Termwert keinem der Werte Wert_1, Wert_2, ..., so werden die Default-Anweisungen ausgeführt.",
    "%": "```\na % b\n```  \n (sprich: 'a modulo b') berechnet den **Rest** der ganzzahligen Division a/b.",
    "|": "```\na | b\n```  \n (sprich: 'a or b') berechnet die **bitweise oder-Verknüpfung** der Werte a und b.",
    "&": "```\na & b\n```  \n (sprich: 'a und b') berechnet die **bitweise und-Verknüpfung** der Werte a und b.",
    "^": "```\na ^ b\n```  \n (sprich: 'a xor b') berechnet die **bitweise exklusiv-oder-Verknüpfung** der Werte a und b.",
    ">>": "```\na >> b\n```  \n (sprich: 'a right shift b') berechnet den Wert, der entsteht, wenn man den Wert von a **bitweise um b Stellen nach rechts verschiebt**. Dieser Wert ist identisch mit dem nach unten abgerundeten Wert von a/(2 hoch b).",
    "<<": "```\na >> b\n```  \n (sprich: 'a left shift b') berechnet den Wert, der entsteht, wenn man den Wert von a **bitweise um b Stellen nach links verschiebt**. Dieser Wert ist identisch mit dem nach unten abgerundeten Wert von a*(2 hoch b).",
    "~": "```\n~a\n```  \n (sprich: 'nicht a') berechnet den Wert, der entsteht, wenn man **alle Bits von a umkehrt**.",
    "==": "```\na == b\n```  \nergibt genau dann ```true```, wenn ```a``` und ```b``` gleich sind.  \nSind a und b **Objekte**, so ergibt ```a == b``` nur dann ```true```, wenn ```a``` und ```b``` auf das **identische** Objekt zeigen.  \n```==``` nennt man **Vergleichsoperator**.",
    "<=": "```\na <= b\n```  \nergibt genau dann ```true```, wenn der Wert von ```a``` kleiner oder gleich dem Wert von ```b``` ist.",
    ">=": "```\na <= b\n```  \nergibt genau dann ```true```, wenn der Wert von ```a``` größer oder gleich dem Wert von ```b``` ist.",
    "!=": "```\na != b\n```  \nergibt genau dann ```true```, wenn ```a``` und ```b``` **un**gleich sind.  \nSind ```a``` und ```b``` **Objekte**, so ergibt ```a != b``` dann ```true```, wenn ```a``` und ```b``` **nicht** auf das **identische** Objekt zeigen.  \n```!=``` nennt man **Ungleich-Operator**.",
    "+=": "```\na += b\n(Kurzschreibweise für a = a + b)\n```  \nbewirkt, dass der Wert von ```a``` um den Wert von ```b``` **erhöht** wird. Das Ergebnis wird in die Variable ```a``` geschrieben.",
    "-=": "```\na -= b\n(Kurzschreibweise für a = a - b)\n```  \nbewirkt, dass der Wert von ```a``` um den Wert von ```b``` **erniedrigt** wird. Das Ergebnis wird in die Variable ```a``` geschrieben.",
    "*=": "```\na *= b\n(Kurzschreibweise für a = a * b)\n```  \nbewirkt, dass der Wert von ```a``` mit dem Wert von ```b``` **multipliziert** wird. Das Ergebnis wird in die Variable ```a``` geschrieben.",
    "/=": "```\na /= b\n(Kurzschreibweise für a = a / b)\n```  \nbewirkt, dass der Wert von ```a``` durch den Wert von ```b``` **dividiert** wird. Das Ergebnis wird in die Variable ```a``` geschrieben.",
    "++": "```\na++\n(Kurzschreibweise für a = a + 1)\n```  \nbewirkt, dass der Wert von ```a``` um eins erhöht wird.",
    "--": "```\na--\n(Kurzschreibweise für a = a - 1)\n```  \nbewirkt, dass der Wert von ```a``` um eins eniedrigt wird.",
    "=": "```\na = Term\n```  \nberechnet den Wert des Terms und weist ihn der Variablen ```a``` zu.  \n**Vorsicht:**  \nVerwechsle ```=```(**Zuweisungsoperator**) nicht mit ```==```(**Vergleichsoperator**)!",
    "!": "```\n!a\n```  \nergibt genau dann ```true```, wenn ```a``` ```false``` ergibt.  \n```!``` spricht man '**nicht**'.",
    "public": "```\npublic\n```  \nAttribute und Methoden, die als ```public``` deklariert werden, sind überall (auch außerhalb der Klasse) sichtbar.",
    "private": "```\nprivate\n```  \nAttribute und Methoden, die als ```private``` deklariert werden, sind nur innerhalb von Methoden derselben Klasse sichtbar.",
    "protected": "```\nprotected\n```  \nAttribute und Methoden, die als ```protected``` deklariert werden, sind nur innerhalb von Methoden derselben Klasse oder innerhalb von Methoden von Kindklassen sichtbar.",
    "return": "```\nreturn Term\n```  \nbewirkt, dass die Methode verlassen wird und der Wert des Terms an die aufrufende Stelle zurückgegeben wird.",
    "break": "```\nbreak;\n```  \ninnerhalb einer Schleife bewirkt, dass die Schleife sofort verlassen und mit den Anweisungen nach der Schleife fortgefahren wird.  \n" +
        "```break``` innerhalb einer ```switch```-Anweisung bewirkt, dass der Block der ```switch```-Anweisung verlassen wird.",
    "class": "```\nclass\n```  \nMit dem Schlüsselwort ```class``` werden Klassen definiert.",
    "extends": "```\nextends\n```  \n```class A extends B { ... }``` bedeutet, dass die Klasse A Unterklasse der Klasse B ist.",
    "implements": "```\nimplements\n```  \n```class A implements B { ... }``` bedeutet, dass die Klasse A das Interface B implementiert, d.h., dass sie alle Methoden besitzen muss, die in B definiert sind.",
    "this": "```\nthis\n```  \nInnerhalb einer Methodendefinition bezeichnet das Schlüsselwort ```this``` immer dasjenige Objekt, für das die Methode gerade ausgeführt wird.",
    "var": "```\nvar\n```  \nWird einer Variable beim Deklarieren sofort ein Startwert zugewiesen (z.B. Circle c = new Circle(100, 100, 10)), so kann statt des Datentyps das Schlüsselwort ```var``` verwendet werden (also var c = new Circle(100, 100, 10)).",
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTXlIb3ZlclByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9tYWluL2d1aS9NeUhvdmVyUHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNqRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNqRixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUNsSCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUlwRSxNQUFNLE9BQU8sZUFBZTtJQTRDeEIsWUFBb0IsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7SUFFbEMsQ0FBQztJQUVELFlBQVksQ0FBQyxLQUErQixFQUFFLFFBQXlCLEVBQUUsS0FBK0I7O1FBR3BHLElBQUksU0FBUyxHQUFxQixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUVwRSxpSUFBaUk7UUFDakksc0JBQXNCO1FBQ3RCLElBQUcsU0FBUyxJQUFJLElBQUksRUFBQztZQUNqQixJQUFHLFNBQVMsQ0FBQyxlQUFlLElBQUksU0FBUyxDQUFDLGFBQWEsSUFBSSxTQUFTLENBQUMsV0FBVyxJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUM7Z0JBQ3BHLElBQ0ksQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHLFFBQVEsQ0FBQyxVQUFVLElBQUksU0FBUyxDQUFDLGVBQWUsSUFBSSxRQUFRLENBQUMsVUFBVSxJQUFJLFNBQVMsQ0FBQyxXQUFXLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQztvQkFDakosQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFFBQVEsQ0FBQyxVQUFVLElBQUksU0FBUyxDQUFDLGFBQWEs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dUk7SUFDakosT0FBTyxFQUFFLDJKQUEySjtRQUNwSyx1SEFBdUg7SUFDdkgsT0FBTyxFQUFFLGdGQUFnRjtJQUN6RixTQUFTLEVBQUUsZ0hBQWdIO0lBQzNILFlBQVksRUFBRSw0TEFBNEw7SUFDMU0sTUFBTSxFQUFFLGtLQUFrSztJQUMxSyxLQUFLLEVBQUUscVBBQXFQO0NBQy9QLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tIFwiLi9FZGl0b3IuanNcIjtcclxuaW1wb3J0IHsgTW9kdWxlIH0gZnJvbSBcIi4uLy4uL2NvbXBpbGVyL3BhcnNlci9Nb2R1bGUuanNcIjtcclxuaW1wb3J0IHsgS2xhc3MsIEludGVyZmFjZSB9IGZyb20gXCIuLi8uLi9jb21waWxlci90eXBlcy9DbGFzcy5qc1wiO1xyXG5pbXBvcnQgeyBNZXRob2QsIEF0dHJpYnV0ZSwgUHJpbWl0aXZlVHlwZSB9IGZyb20gXCIuLi8uLi9jb21waWxlci90eXBlcy9UeXBlcy5qc1wiO1xyXG5pbXBvcnQgeyBnZXREZWNsYXJhdGlvbkFzU3RyaW5nLCBnZXRHZW5lcmljUGFyYW1ldGVyRGVmaW5pdGlvbiB9IGZyb20gXCIuLi8uLi9jb21waWxlci90eXBlcy9EZWNsYXJhdGlvbkhlbHBlci5qc1wiO1xyXG5pbXBvcnQgeyBJbnRlcnByZXRlclN0YXRlIH0gZnJvbSBcIi4uLy4uL2ludGVycHJldGVyL0ludGVycHJldGVyLmpzXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBNeUhvdmVyUHJvdmlkZXIge1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGtleXdvcmREZXNjcmlwdGlvbnM6IHsgW2tleXdvcmQ6IHN0cmluZ106IHN0cmluZyB9ID0ge1xyXG4gICAgICAgIFwicHJpbnRcIjogXCJEaWUgQW53ZWlzdW5nIGBgYHByaW50YGBgIGdpYnQgZWluZSBaZWljaGVua2V0dGUgYXVzLlwiLFxyXG4gICAgICAgIFwibmV3XCI6IFwiRGFzIFNjaGzDvHNzZWx3b3J0IGBgYG5ld2BgYCBiZXdpcmt0IGRpZSBJbnN0YW56aWVydW5nIChcXFwiRXJzY2hhZmZ1bmdcXFwiKSBlaW5lcyBuZXVlbiBPYmpla3RlcyBlaW5lciBLbGFzc2UuXCIsXHJcbiAgICAgICAgXCJwcmludGxuXCI6IFwiRGllIEFud2Vpc3VuZyBgYGBwcmludGxuYGBgIGdpYnQgZWluZSBaZWljaGVua2V0dGUgZ2Vmb2xndCB2b24gZWluZW0gWmVpbGVudW1icnVjaCBhdXMuXCIsXHJcbiAgICAgICAgXCJ3aGlsZVwiOiBcImBgYFxcbndoaWxlIChCZWRpbmd1bmcpIHtBbndlaXN1bmdlbn1cXG5gYGAgIFxcbmJld2lya3QgZGllIFdpZWRlcmhvbHVuZyBkZXIgQW53ZWlzdW5nZW4gc29sYW5nZSBgYGBCZWRpbmd1bmcgPT0gdHJ1ZWBgYCBpc3QuXCIsXHJcbiAgICAgICAgXCJmb3JcIjogXCJgYGBcXG5mb3IoU3RhcnRhbndlaXN1bmc7U29sYW5nZS1CZWRpbmd1bmc7TmFjaF9qZWRlcl9XaWVkZXJob2x1bmcpe0Fud2Vpc3VuZ2VufVxcbmBgYCAgXFxuXCJcclxuICAgICAgICAgICAgKyBcImbDvGhydCB6dW7DpGNoc3QgZGllIFN0YXJ0YW53ZWlzdW5nIGF1cyB1bmQgd2llZGVyaG9sdCBkYW5uIGRpZSBBbndlaXN1bmdlbiBzb2xhbmdlIGBgYEJlZGluZ3VuZyA9PSB0cnVlYGBgIGlzdC4gQW0gRW5kZSBqZWRlciB3aWVkZXJob2x1bmcgd2lyZCBOYWNoX2plZGVyX1dpZWRlcmhvbHVuZyBhdXNnZWbDvGhydC5cIixcclxuICAgICAgICBcImlmXCI6IFwiYGBgXFxuaWYoQmVkaW5ndW5nKXtBbndlaXN1bmdlbl8xfSBlbHNlIHtBbndlaXN1bmdlbl8yfVxcbmBgYCAgXFxud2VydGV0IGRpZSBCZWRpbmd1bmcgYXVzIHVuZCBmw7xocnQgQW53ZWlzdW5nZW5fMSBudXIgZGFubiBhdXMsIHdlbm4gZGllIEJlZGluZ3VuZyBgYGB0cnVlYGBgIGVyZ2lidCwgQW53ZWlzdW5nZW5fMiBudXIgZGFubiwgd2VubiBkaWUgQmVkaW5ndW5nIGBgYGZhbHNlYGBgIGVyZ2lidC4gIFxcbkRlciBgYGBlbHNlYGBgLVRlaWwga2FubiBhdWNoIHdlZ2dlbGFzc2VuIHdlcmRlbi5cIixcclxuICAgICAgICBcImVsc2VcIjogXCJgYGBcXG5pZihCZWRpbmd1bmcpe0Fud2Vpc3VuZ2VuXzF9IGVsc2Uge0Fud2Vpc3VuZ2VuXzJ9XFxuYGBgICBcXG53ZXJ0ZXQgZGllIEJlZGluZ3VuZyBhdXMgdW5kIGbDvGhydCBBbndlaXN1bmdlbl8xIG51ciBkYW5uIGF1cywgd2VubiBkaWUgQmVkaW5ndW5nIGBgYHRydWVgYGAgZXJnaWJ0LCBBbndlaXN1bmdlbl8yIG51ciBkYW5uLCB3ZW5uIGRpZSBCZWRpbmd1bmcgYGBgZmFsc2VgYGAgZXJnaWJ0LlwiLFxyXG4gICAgICAgIFwic3dpdGNoXCI6IFwiYGBgXFxuc3dpdGNoKFNlbGVrdG9yKXsgY2FzZSBXZXJ0XzE6IEFud2Vpc3VuZ2VuXzE7IGJyZWFrOyBjYXNlIFdlcnRfMjogQW53ZWlzdW5nZW5fMjsgYnJlYWs7IGRlZmF1bHQ6IERlZmF1bHQtQW53ZWlzdW5nZW4gfSBcXG5gYGAgIFxcbndlcnRldCBkZW4gU2VsZWt0b3ItVGVybSBhdXMgdW5kIGbDvGhydCBhYmjDpG5naWcgdm9tIFRlcm13ZXJ0IEFud2Vpc3VuZ2VuXzEsIEFud2Vpc3VuZ2VuXzIsIC4uLiBhdXMuIEVudHNwcmljaHQgZGVyIFRlcm13ZXJ0IGtlaW5lbSBkZXIgV2VydGUgV2VydF8xLCBXZXJ0XzIsIC4uLiwgc28gd2VyZGVuIGRpZSBEZWZhdWx0LUFud2Vpc3VuZ2VuIGF1c2dlZsO8aHJ0LlwiLFxyXG4gICAgICAgIFwiJVwiOiBcImBgYFxcbmEgJSBiXFxuYGBgICBcXG4gKHNwcmljaDogJ2EgbW9kdWxvIGInKSBiZXJlY2huZXQgZGVuICoqUmVzdCoqIGRlciBnYW56emFobGlnZW4gRGl2aXNpb24gYS9iLlwiLFxyXG4gICAgICAgIFwifFwiOiBcImBgYFxcbmEgfCBiXFxuYGBgICBcXG4gKHNwcmljaDogJ2Egb3IgYicpIGJlcmVjaG5ldCBkaWUgKipiaXR3ZWlzZSBvZGVyLVZlcmtuw7xwZnVuZyoqIGRlciBXZXJ0ZSBhIHVuZCBiLlwiLFxyXG4gICAgICAgIFwiJlwiOiBcImBgYFxcbmEgJiBiXFxuYGBgICBcXG4gKHNwcmljaDogJ2EgdW5kIGInKSBiZXJlY2huZXQgZGllICoqYml0d2Vpc2UgdW5kLVZlcmtuw7xwZnVuZyoqIGRlciBXZXJ0ZSBhIHVuZCBiLlwiLFxyXG4gICAgICAgIFwiXlwiOiBcImBgYFxcbmEgXiBiXFxuYGBgICBcXG4gKHNwcmljaDogJ2EgeG9yIGInKSBiZXJlY2huZXQgZGllICoqYml0d2Vpc2UgZXhrbHVzaXYtb2Rlci1WZXJrbsO8cGZ1bmcqKiBkZXIgV2VydGUgYSB1bmQgYi5cIixcclxuICAgICAgICBcIj4+XCI6IFwiYGBgXFxuYSA+PiBiXFxuYGBgICBcXG4gKHNwcmljaDogJ2EgcmlnaHQgc2hpZnQgYicpIGJlcmVjaG5ldCBkZW4gV2VydCwgZGVyIGVudHN0ZWh0LCB3ZW5uIG1hbiBkZW4gV2VydCB2b24gYSAqKmJpdHdlaXNlIHVtIGIgU3RlbGxlbiBuYWNoIHJlY2h0cyB2ZXJzY2hpZWJ0KiouIERpZXNlciBXZXJ0IGlzdCBpZGVudGlzY2ggbWl0IGRlbSBuYWNoIHVudGVuIGFiZ2VydW5kZXRlbiBXZXJ0IHZvbiBhLygyIGhvY2ggYikuXCIsXHJcbiAgICAgICAgXCI8PFwiOiBcImBgYFxcbmEgPj4gYlxcbmBgYCAgXFxuIChzcHJpY2g6ICdhIGxlZnQgc2hpZnQgYicpIGJlcmVjaG5ldCBkZW4gV2VydCwgZGVyIGVudHN0ZWh0LCB3ZW5uIG1hbiBkZW4gV2VydCB2b24gYSAqKmJpdHdlaXNlIHVtIGIgU3RlbGxlbiBuYWNoIGxpbmtzIHZlcnNjaGllYnQqKi4gRGllc2VyIFdlcnQgaXN0IGlkZW50aXNjaCBtaXQgZGVtIG5hY2ggdW50ZW4gYWJnZXJ1bmRldGVuIFdlcnQgdm9uIGEqKDIgaG9jaCBiKS5cIixcclxuICAgICAgICBcIn5cIjogXCJgYGBcXG5+YVxcbmBgYCAgXFxuIChzcHJpY2g6ICduaWNodCBhJykgYmVyZWNobmV0IGRlbiBXZXJ0LCBkZXIgZW50c3RlaHQsIHdlbm4gbWFuICoqYWxsZSBCaXRzIHZvbiBhIHVta2VocnQqKi5cIixcclxuICAgICAgICBcIj09XCI6IFwiYGBgXFxuYSA9PSBiXFxuYGBgICBcXG5lcmdpYnQgZ2VuYXUgZGFubiBgYGB0cnVlYGBgLCB3ZW5uIGBgYGFgYGAgdW5kIGBgYGJgYGAgZ2xlaWNoIHNpbmQuICBcXG5TaW5kIGEgdW5kIGIgKipPYmpla3RlKiosIHNvIGVyZ2lidCBgYGBhID09IGJgYGAgbnVyIGRhbm4gYGBgdHJ1ZWBgYCwgd2VubiBgYGBhYGBgIHVuZCBgYGBiYGBgIGF1ZiBkYXMgKippZGVudGlzY2hlKiogT2JqZWt0IHplaWdlbi4gIFxcbmBgYD09YGBgIG5lbm50IG1hbiAqKlZlcmdsZWljaHNvcGVyYXRvcioqLlwiLFxyXG4gICAgICAgIFwiPD1cIjogXCJgYGBcXG5hIDw9IGJcXG5gYGAgIFxcbmVyZ2lidCBnZW5hdSBkYW5uIGBgYHRydWVgYGAsIHdlbm4gZGVyIFdlcnQgdm9uIGBgYGFgYGAga2xlaW5lciBvZGVyIGdsZWljaCBkZW0gV2VydCB2b24gYGBgYmBgYCBpc3QuXCIsXHJcbiAgICAgICAgXCI+PVwiOiBcImBgYFxcbmEgPD0gYlxcbmBgYCAgXFxuZXJnaWJ0IGdlbmF1IGRhbm4gYGBgdHJ1ZWBgYCwgd2VubiBkZXIgV2VydCB2b24gYGBgYWBgYCBncsO2w59lciBvZGVyIGdsZWljaCBkZW0gV2VydCB2b24gYGBgYmBgYCBpc3QuXCIsXHJcbiAgICAgICAgXCIhPVwiOiBcImBgYFxcbmEgIT0gYlxcbmBgYCAgXFxuZXJnaWJ0IGdlbmF1IGRhbm4gYGBgdHJ1ZWBgYCwgd2VubiBgYGBhYGBgIHVuZCBgYGBiYGBgICoqdW4qKmdsZWljaCBzaW5kLiAgXFxuU2luZCBgYGBhYGBgIHVuZCBgYGBiYGBgICoqT2JqZWt0ZSoqLCBzbyBlcmdpYnQgYGBgYSAhPSBiYGBgIGRhbm4gYGBgdHJ1ZWBgYCwgd2VubiBgYGBhYGBgIHVuZCBgYGBiYGBgICoqbmljaHQqKiBhdWYgZGFzICoqaWRlbnRpc2NoZSoqIE9iamVrdCB6ZWlnZW4uICBcXG5gYGAhPWBgYCBuZW5udCBtYW4gKipVbmdsZWljaC1PcGVyYXRvcioqLlwiLFxyXG4gICAgICAgIFwiKz1cIjogXCJgYGBcXG5hICs9IGJcXG4oS3VyenNjaHJlaWJ3ZWlzZSBmw7xyIGEgPSBhICsgYilcXG5gYGAgIFxcbmJld2lya3QsIGRhc3MgZGVyIFdlcnQgdm9uIGBgYGFgYGAgdW0gZGVuIFdlcnQgdm9uIGBgYGJgYGAgKiplcmjDtmh0Kiogd2lyZC4gRGFzIEVyZ2VibmlzIHdpcmQgaW4gZGllIFZhcmlhYmxlIGBgYGFgYGAgZ2VzY2hyaWViZW4uXCIsXHJcbiAgICAgICAgXCItPVwiOiBcImBgYFxcbmEgLT0gYlxcbihLdXJ6c2NocmVpYndlaXNlIGbDvHIgYSA9IGEgLSBiKVxcbmBgYCAgXFxuYmV3aXJrdCwgZGFzcyBkZXIgV2VydCB2b24gYGBgYWBgYCB1bSBkZW4gV2VydCB2b24gYGBgYmBgYCAqKmVybmllZHJpZ3QqKiB3aXJkLiBEYXMgRXJnZWJuaXMgd2lyZCBpbiBkaWUgVmFyaWFibGUgYGBgYWBgYCBnZXNjaHJpZWJlbi5cIixcclxuICAgICAgICBcIio9XCI6IFwiYGBgXFxuYSAqPSBiXFxuKEt1cnpzY2hyZWlid2Vpc2UgZsO8ciBhID0gYSAqIGIpXFxuYGBgICBcXG5iZXdpcmt0LCBkYXNzIGRlciBXZXJ0IHZvbiBgYGBhYGBgIG1pdCBkZW0gV2VydCB2b24gYGBgYmBgYCAqKm11bHRpcGxpemllcnQqKiB3aXJkLiBEYXMgRXJnZWJuaXMgd2lyZCBpbiBkaWUgVmFyaWFibGUgYGBgYWBgYCBnZXNjaHJpZWJlbi5cIixcclxuICAgICAgICBcIi89XCI6IFwiYGBgXFxuYSAvPSBiXFxuKEt1cnpzY2hyZWlid2Vpc2UgZsO8ciBhID0gYSAvIGIpXFxuYGBgICBcXG5iZXdpcmt0LCBkYXNzIGRlciBXZXJ0IHZvbiBgYGBhYGBgIGR1cmNoIGRlbiBXZXJ0IHZvbiBgYGBiYGBgICoqZGl2aWRpZXJ0Kiogd2lyZC4gRGFzIEVyZ2VibmlzIHdpcmQgaW4gZGllIFZhcmlhYmxlIGBgYGFgYGAgZ2VzY2hyaWViZW4uXCIsXHJcbiAgICAgICAgXCIrK1wiOiBcImBgYFxcbmErK1xcbihLdXJ6c2NocmVpYndlaXNlIGbDvHIgYSA9IGEgKyAxKVxcbmBgYCAgXFxuYmV3aXJrdCwgZGFzcyBkZXIgV2VydCB2b24gYGBgYWBgYCB1bSBlaW5zIGVyaMO2aHQgd2lyZC5cIixcclxuICAgICAgICBcIi0tXCI6IFwiYGBgXFxuYS0tXFxuKEt1cnpzY2hyZWlid2Vpc2UgZsO8ciBhID0gYSAtIDEpXFxuYGBgICBcXG5iZXdpcmt0LCBkYXNzIGRlciBXZXJ0IHZvbiBgYGBhYGBgIHVtIGVpbnMgZW5pZWRyaWd0IHdpcmQuXCIsXHJcbiAgICAgICAgXCI9XCI6IFwiYGBgXFxuYSA9IFRlcm1cXG5gYGAgIFxcbmJlcmVjaG5ldCBkZW4gV2VydCBkZXMgVGVybXMgdW5kIHdlaXN0IGlobiBkZXIgVmFyaWFibGVuIGBgYGFgYGAgenUuICBcXG4qKlZvcnNpY2h0OioqICBcXG5WZXJ3ZWNoc2xlIGBgYD1gYGAoKipadXdlaXN1bmdzb3BlcmF0b3IqKikgbmljaHQgbWl0IGBgYD09YGBgKCoqVmVyZ2xlaWNoc29wZXJhdG9yKiopIVwiLFxyXG4gICAgICAgIFwiIVwiOiBcImBgYFxcbiFhXFxuYGBgICBcXG5lcmdpYnQgZ2VuYXUgZGFubiBgYGB0cnVlYGBgLCB3ZW5uIGBgYGFgYGAgYGBgZmFsc2VgYGAgZXJnaWJ0LiAgXFxuYGBgIWBgYCBzcHJpY2h0IG1hbiAnKipuaWNodCoqJy5cIixcclxuICAgICAgICBcInB1YmxpY1wiOiBcImBgYFxcbnB1YmxpY1xcbmBgYCAgXFxuQXR0cmlidXRlIHVuZCBNZXRob2RlbiwgZGllIGFscyBgYGBwdWJsaWNgYGAgZGVrbGFyaWVydCB3ZXJkZW4sIHNpbmQgw7xiZXJhbGwgKGF1Y2ggYXXDn2VyaGFsYiBkZXIgS2xhc3NlKSBzaWNodGJhci5cIixcclxuICAgICAgICBcInByaXZhdGVcIjogXCJgYGBcXG5wcml2YXRlXFxuYGBgICBcXG5BdHRyaWJ1dGUgdW5kIE1ldGhvZGVuLCBkaWUgYWxzIGBgYHByaXZhdGVgYGAgZGVrbGFyaWVydCB3ZXJkZW4sIHNpbmQgbnVyIGlubmVyaGFsYiB2b24gTWV0aG9kZW4gZGVyc2VsYmVuIEtsYXNzZSBzaWNodGJhci5cIixcclxuICAgICAgICBcInByb3RlY3RlZFwiOiBcImBgYFxcbnByb3RlY3RlZFxcbmBgYCAgXFxuQXR0cmlidXRlIHVuZCBNZXRob2RlbiwgZGllIGFscyBgYGBwcm90ZWN0ZWRgYGAgZGVrbGFyaWVydCB3ZXJkZW4sIHNpbmQgbnVyIGlubmVyaGFsYiB2b24gTWV0aG9kZW4gZGVyc2VsYmVuIEtsYXNzZSBvZGVyIGlubmVyaGFsYiB2b24gTWV0aG9kZW4gdm9uIEtpbmRrbGFzc2VuIHNpY2h0YmFyLlwiLFxyXG4gICAgICAgIFwicmV0dXJuXCI6IFwiYGBgXFxucmV0dXJuIFRlcm1cXG5gYGAgIFxcbmJld2lya3QsIGRhc3MgZGllIE1ldGhvZGUgdmVybGFzc2VuIHdpcmQgdW5kIGRlciBXZXJ0IGRlcyBUZXJtcyBhbiBkaWUgYXVmcnVmZW5kZSBTdGVsbGUgenVyw7xja2dlZ2ViZW4gd2lyZC5cIixcclxuICAgICAgICBcImJyZWFrXCI6IFwiYGBgXFxuYnJlYWs7XFxuYGBgICBcXG5pbm5lcmhhbGIgZWluZXIgU2NobGVpZmUgYmV3aXJrdCwgZGFzcyBkaWUgU2NobGVpZmUgc29mb3J0IHZlcmxhc3NlbiB1bmQgbWl0IGRlbiBBbndlaXN1bmdlbiBuYWNoIGRlciBTY2hsZWlmZSBmb3J0Z2VmYWhyZW4gd2lyZC4gIFxcblwiK1xyXG4gICAgICAgIFwiYGBgYnJlYWtgYGAgaW5uZXJoYWxiIGVpbmVyIGBgYHN3aXRjaGBgYC1BbndlaXN1bmcgYmV3aXJrdCwgZGFzcyBkZXIgQmxvY2sgZGVyIGBgYHN3aXRjaGBgYC1BbndlaXN1bmcgdmVybGFzc2VuIHdpcmQuXCIsXHJcbiAgICAgICAgXCJjbGFzc1wiOiBcImBgYFxcbmNsYXNzXFxuYGBgICBcXG5NaXQgZGVtIFNjaGzDvHNzZWx3b3J0IGBgYGNsYXNzYGBgIHdlcmRlbiBLbGFzc2VuIGRlZmluaWVydC5cIixcclxuICAgICAgICBcImV4dGVuZHNcIjogXCJgYGBcXG5leHRlbmRzXFxuYGBgICBcXG5gYGBjbGFzcyBBIGV4dGVuZHMgQiB7IC4uLiB9YGBgIGJlZGV1dGV0LCBkYXNzIGRpZSBLbGFzc2UgQSBVbnRlcmtsYXNzZSBkZXIgS2xhc3NlIEIgaXN0LlwiLFxyXG4gICAgICAgIFwiaW1wbGVtZW50c1wiOiBcImBgYFxcbmltcGxlbWVudHNcXG5gYGAgIFxcbmBgYGNsYXNzIEEgaW1wbGVtZW50cyBCIHsgLi4uIH1gYGAgYmVkZXV0ZXQsIGRhc3MgZGllIEtsYXNzZSBBIGRhcyBJbnRlcmZhY2UgQiBpbXBsZW1lbnRpZXJ0LCBkLmguLCBkYXNzIHNpZSBhbGxlIE1ldGhvZGVuIGJlc2l0emVuIG11c3MsIGRpZSBpbiBCIGRlZmluaWVydCBzaW5kLlwiLFxyXG4gICAgICAgIFwidGhpc1wiOiBcImBgYFxcbnRoaXNcXG5gYGAgIFxcbklubmVyaGFsYiBlaW5lciBNZXRob2RlbmRlZmluaXRpb24gYmV6ZWljaG5ldCBkYXMgU2NobMO8c3NlbHdvcnQgYGBgdGhpc2BgYCBpbW1lciBkYXNqZW5pZ2UgT2JqZWt0LCBmw7xyIGRhcyBkaWUgTWV0aG9kZSBnZXJhZGUgYXVzZ2Vmw7xocnQgd2lyZC5cIixcclxuICAgICAgICBcInZhclwiOiBcImBgYFxcbnZhclxcbmBgYCAgXFxuV2lyZCBlaW5lciBWYXJpYWJsZSBiZWltIERla2xhcmllcmVuIHNvZm9ydCBlaW4gU3RhcnR3ZXJ0IHp1Z2V3aWVzZW4gKHouQi4gQ2lyY2xlIGMgPSBuZXcgQ2lyY2xlKDEwMCwgMTAwLCAxMCkpLCBzbyBrYW5uIHN0YXR0IGRlcyBEYXRlbnR5cHMgZGFzIFNjaGzDvHNzZWx3b3J0IGBgYHZhcmBgYCB2ZXJ3ZW5kZXQgd2VyZGVuIChhbHNvIHZhciBjID0gbmV3IENpcmNsZSgxMDAsIDEwMCwgMTApKS5cIixcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVkaXRvcjogRWRpdG9yKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByb3ZpZGVIb3Zlcihtb2RlbDogbW9uYWNvLmVkaXRvci5JVGV4dE1vZGVsLCBwb3NpdGlvbjogbW9uYWNvLlBvc2l0aW9uLCB0b2tlbjogbW9uYWNvLkNhbmNlbGxhdGlvblRva2VuKTpcclxuICAgICAgICBtb25hY28ubGFuZ3VhZ2VzLlByb3ZpZGVyUmVzdWx0PG1vbmFjby5sYW5ndWFnZXMuSG92ZXI+IHtcclxuXHJcbiAgICAgICAgbGV0IHNlbGVjdGlvbjogbW9uYWNvLlNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmVkaXRvci5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBpZiBjdXJzb3IgaXMgaW5zaWRlIGN1cnJlbnQgc2VsZWN0aW9uIHRoZW4gZG9uJ3Qgc2hvdyBob3ZlciwgYmVjYXVzZSBlZGl0b3Iub25EaWRDaGFuZ2VDdXJzb3JQb3NpdGlvbiBldmFsdWF0ZXMgc2VsZWN0ZWQgVGV4dCBcclxuICAgICAgICAvLyAoc2VlIGNsYXNzIEVkaXRvcikuXHJcbiAgICAgICAgaWYoc2VsZWN0aW9uICE9IG51bGwpe1xyXG4gICAgICAgICAgICBpZihzZWxlY3Rpb24uc3RhcnRMaW5lTnVtYmVyICE9IHNlbGVjdGlvbi5lbmRMaW5lTnVtYmVyIHx8IHNlbGVjdGlvbi5zdGFydENvbHVtbiAhPSBzZWxlY3Rpb24uZW5kQ29sdW1uKXtcclxuICAgICAgICAgICAgICAgIGlmKFxyXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3Rpb24uc3RhcnRMaW5lTnVtYmVyIDwgcG9zaXRpb24ubGluZU51bWJlciB8fCBzZWxlY3Rpb24uc3RhcnRMaW5lTnVtYmVyID09IHBvc2l0aW9uLmxpbmVOdW1iZXIgJiYgc2VsZWN0aW9uLnN0YXJ0Q29sdW1uIDw9IHBvc2l0aW9uLmNvbHVtbikgJiYgXHJcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGlvbi5lbmRMaW5lTnVtYmVyID4gcG9zaXRpb24ubGluZU51bWJlciB8fCBzZWxlY3Rpb24uZW5kTGluZU51bWJlciA9PSBwb3NpdGlvbi5saW5lTnVtYmVyICYmIHNlbGVjdGlvbi5lbmRDb2x1bW4gPj0gcG9zaXRpb24uY29sdW1uKSBcclxuICAgICAgICAgICAgICAgICl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbW9kdWxlOiBNb2R1bGUgPSB0aGlzLmVkaXRvci5tYWluLmdldEN1cnJlbnRXb3Jrc3BhY2UoKT8uZ2V0TW9kdWxlQnlNb25hY29Nb2RlbChtb2RlbCk7XHJcblxyXG4gICAgICAgIGlmIChtb2R1bGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcihsZXQgZXJyb3JMaXN0IG9mIG1vZHVsZS5lcnJvcnMpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGVycm9yIG9mIGVycm9yTGlzdCl7XHJcbiAgICAgICAgICAgICAgICBpZihlcnJvci5wb3NpdGlvbi5saW5lID09IHBvc2l0aW9uLmxpbmVOdW1iZXIgJiYgXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucG9zaXRpb24uY29sdW1uIDw9IHBvc2l0aW9uLmNvbHVtbiAmJiBcclxuICAgICAgICAgICAgICAgICAgICBlcnJvci5wb3NpdGlvbi5jb2x1bW4gKyBlcnJvci5wb3NpdGlvbi5sZW5ndGggPj0gcG9zaXRpb24uY29sdW1uKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIFNob3cgZXJyb3ItdG9vbHRpcCBhbmQgZG9uJ3Qgc2hvdyBob3Zlci10b29sdGlwXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZWxlbWVudCA9IG1vZHVsZS5nZXRFbGVtZW50QXRQb3NpdGlvbihwb3NpdGlvbi5saW5lTnVtYmVyLCBwb3NpdGlvbi5jb2x1bW4pO1xyXG5cclxuICAgICAgICBsZXQgZGVjbGFyYXRpb25Bc1N0cmluZyA9IFwiXCI7XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC5pZGVudGlmaWVyICE9IFwidmFyXCIpIHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBLbGFzcyB8fCBlbGVtZW50IGluc3RhbmNlb2YgTWV0aG9kIHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBJbnRlcmZhY2VcclxuICAgICAgICAgICAgICAgIHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uQXNTdHJpbmcgPSBnZXREZWNsYXJhdGlvbkFzU3RyaW5nKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBQcmltaXRpdmVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbkFzU3RyaW5nID0gXCJgYGBcXG5cIiArIGVsZW1lbnQuaWRlbnRpZmllciArIFwiXFxuYGBgICBcXG5wcmltaXRpdmVyIERhdGVudHlwOiBcIiArIGVsZW1lbnQuZGVzY3JpcHRpb24gKyBcIlwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByYW5nZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50czogW3sgdmFsdWU6IGRlY2xhcmF0aW9uQXNTdHJpbmcgfV0sXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgbGV0IHR5cGVJZGVudGlmaWVyOiBzdHJpbmcgPSBlbGVtZW50Py50eXBlPy5pZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudD8udHlwZSBpbnN0YW5jZW9mIEtsYXNzIHx8IGVsZW1lbnQ/LnR5cGUgaW5zdGFuY2VvZiBJbnRlcmZhY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZGVudGlmaWVyICs9IFwiIFwiICsgZ2V0R2VuZXJpY1BhcmFtZXRlckRlZmluaXRpb24oZWxlbWVudC50eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZUlkZW50aWZpZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZGVudGlmaWVyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZUlkZW50aWZpZXIgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25Bc1N0cmluZyA9IHR5cGVJZGVudGlmaWVyICsgZWxlbWVudD8uaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB3b3JkID0gdGhpcy5nZXRXb3JkVW5kZXJDdXJzb3IobW9kZWwsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgbGV0IGRlc2MgPSBNeUhvdmVyUHJvdmlkZXIua2V5d29yZERlc2NyaXB0aW9uc1t3b3JkXTtcclxuICAgICAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByYW5nZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50czogW3sgdmFsdWU6IGRlc2MgfV0sXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZWRpdG9yLm1haW4uZ2V0SW50ZXJwcmV0ZXIoKS5zdGF0ZTtcclxuXHJcbiAgICAgICAgbGV0IHZhbHVlOiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUgPT0gSW50ZXJwcmV0ZXJTdGF0ZS5wYXVzZWQpIHtcclxuICAgICAgICAgICAgbGV0IGV2YWx1YXRvciA9IHRoaXMuZWRpdG9yLm1haW4uZ2V0Q3VycmVudFdvcmtzcGFjZSgpLmV2YWx1YXRvcjtcclxuXHJcbiAgICAgICAgICAgIGxldCBpZGVudGlmaWVyOiBzdHJpbmcgPSB0aGlzLndpZGVuRGVjbGFyYXRpb24obW9kZWwsIHBvc2l0aW9uLCBlbGVtZW50Py5pZGVudGlmaWVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGlkZW50aWZpZXIgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGV2YWx1YXRvci5ldmFsdWF0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvciA9PSBudWxsICYmIHJlc3VsdC52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZS50eXBlLmRlYnVnT3V0cHV0KHJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbkFzU3RyaW5nID0gaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb250ZW50cyA9IFtdO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiBkZWNsYXJhdGlvbkFzU3RyaW5nLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCArIGRlY2xhcmF0aW9uQXNTdHJpbmcubGVuZ3RoID4gNDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRzLnB1c2goeyB2YWx1ZTogJ2BgYFxcbicgKyBkZWNsYXJhdGlvbkFzU3RyaW5nICsgJyA9PVxcbmBgYCcgfSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50cy5wdXNoKHsgdmFsdWU6ICdgYGBcXG4nICsgdmFsdWUucmVwbGFjZSgvJm5ic3A7L2csIFwiIFwiKSArICdcXG5gYGAnIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGVudHMucHVzaCh7IHZhbHVlOiAnYGBgXFxuJyArIGRlY2xhcmF0aW9uQXNTdHJpbmcgKyBcIiA9PSBcIiArIHZhbHVlLnJlcGxhY2UoLyZuYnNwOy9nLCBcIiBcIikgKyAnXFxuYGBgJyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnRzLnB1c2goeyB2YWx1ZTogJ2BgYFxcbicgKyBkZWNsYXJhdGlvbkFzU3RyaW5nICsgJ1xcbmBgYCcgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmFuZ2UgPSBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXHJcbiAgICAgICAgICAgIGNvbnRlbnRzOiBjb250ZW50cyxcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldFdvcmRVbmRlckN1cnNvcihtb2RlbDogbW9uYWNvLmVkaXRvci5JVGV4dE1vZGVsLCBwb3NpdGlvbjogbW9uYWNvLlBvc2l0aW9uKVxyXG4gICAgICAgICA6IHN0cmluZyB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHBvcyA9IG1vZGVsLmdldFZhbHVlTGVuZ3RoSW5SYW5nZSh7XHJcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiAwLFxyXG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IDAsXHJcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IHBvc2l0aW9uLmxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgIGVuZENvbHVtbjogcG9zaXRpb24uY29sdW1uXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCB0ZXh0ID0gbW9kZWwuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgICAgbGV0IHdvcmQgPSBcIlwiO1xyXG5cclxuICAgICAgICBsZXQgZW5kID0gcG9zO1xyXG4gICAgICAgIHdoaWxlIChlbmQgPCB0ZXh0Lmxlbmd0aCAmJiB0aGlzLmlzSW5zaWRlSWRlbnRpZmllck9yQXJyYXlEZXNjcmlwdG9yKHRleHQuY2hhckF0KGVuZCkpKSB7XHJcbiAgICAgICAgICAgIGVuZCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGJlZ2luID0gcG9zO1xyXG4gICAgICAgIHdoaWxlIChiZWdpbiA+IDAgJiYgdGhpcy5pc0luc2lkZUlkZW50aWZpZXJPckFycmF5RGVzY3JpcHRvcih0ZXh0LmNoYXJBdChiZWdpbiAtIDEpKSkge1xyXG4gICAgICAgICAgICBiZWdpbi0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVuZCAtIGJlZ2luID4gMSkge1xyXG4gICAgICAgICAgICB3b3JkID0gdGV4dC5zdWJzdHJpbmcoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZW5kID0gcG9zO1xyXG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgdGV4dC5sZW5ndGggJiYgdGhpcy5pc0luc2lkZU9wZXJhdG9yKHRleHQuY2hhckF0KGVuZCkpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIGJlZ2luID0gcG9zO1xyXG4gICAgICAgICAgICB3aGlsZSAoYmVnaW4gPiAwICYmIHRoaXMuaXNJbnNpZGVPcGVyYXRvcih0ZXh0LmNoYXJBdChiZWdpbiAtIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgYmVnaW4tLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIGlmIChlbmQgLSBiZWdpbiA+IDApIHtcclxuICAgICAgICAgICAgICAgIHdvcmQgPSB0ZXh0LnN1YnN0cmluZyhiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHdvcmQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHdpZGVuRGVjbGFyYXRpb24obW9kZWw6IG1vbmFjby5lZGl0b3IuSVRleHRNb2RlbCwgcG9zaXRpb246IG1vbmFjby5Qb3NpdGlvbixcclxuICAgICAgICBpZGVudGlmaWVyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cclxuICAgICAgICBsZXQgcG9zID0gbW9kZWwuZ2V0VmFsdWVMZW5ndGhJblJhbmdlKHtcclxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IDAsXHJcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogMCxcclxuICAgICAgICAgICAgZW5kTGluZU51bWJlcjogcG9zaXRpb24ubGluZU51bWJlcixcclxuICAgICAgICAgICAgZW5kQ29sdW1uOiBwb3NpdGlvbi5jb2x1bW5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHRleHQgPSBtb2RlbC5nZXRWYWx1ZSgpO1xyXG5cclxuICAgICAgICBsZXQgZW5kID0gcG9zO1xyXG4gICAgICAgIHdoaWxlIChlbmQgPCB0ZXh0Lmxlbmd0aCAmJiB0aGlzLmlzSW5zaWRlSWRlbnRpZmllck9yQXJyYXlEZXNjcmlwdG9yKHRleHQuY2hhckF0KGVuZCkpKSB7XHJcbiAgICAgICAgICAgIGVuZCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGJlZ2luID0gcG9zO1xyXG4gICAgICAgIHdoaWxlIChiZWdpbiA+IDAgJiYgdGhpcy5pc0luc2lkZUlkZW50aWZpZXJDaGFpbih0ZXh0LmNoYXJBdChiZWdpbiAtIDEpKSkge1xyXG4gICAgICAgICAgICBiZWdpbi0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxlbmdodDogbnVtYmVyID0gaWRlbnRpZmllcj8ubGVuZ3RoID09IG51bGwgPyAxIDogaWRlbnRpZmllci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChlbmQgLSBiZWdpbiA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcclxuICAgIH1cclxuXHJcbiAgICBpc0luc2lkZUlkZW50aWZpZXJDaGFpbih0OiBzdHJpbmcpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHQudG9Mb2NhbGVMb3dlckNhc2UoKS5tYXRjaCgvW2EtejAtOcOkw7bDvMOfX1xcW1xcXVxcLl0vaSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGlzSW5zaWRlT3BlcmF0b3IodDogc3RyaW5nKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0LnRvTG9jYWxlTG93ZXJDYXNlKCkubWF0Y2goL1shJTw+PVxcK1xcLVxcKlxcL10vaSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGlzSW5zaWRlSWRlbnRpZmllck9yQXJyYXlEZXNjcmlwdG9yKHQ6IHN0cmluZykge1xyXG5cclxuICAgICAgICByZXR1cm4gdC50b0xvY2FsZUxvd2VyQ2FzZSgpLm1hdGNoKC9bYS16MC05w6TDtsO8w59cXFtcXF1dL2kpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59Il19