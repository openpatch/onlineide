var NThreadStatus;
(function (NThreadStatus) {
    NThreadStatus[NThreadStatus["running"] = 0] = "running";
    NThreadStatus[NThreadStatus["callMethod"] = 1] = "callMethod";
    NThreadStatus[NThreadStatus["exited"] = 2] = "exited";
    NThreadStatus[NThreadStatus["exitedWithException"] = 3] = "exitedWithException";
    NThreadStatus[NThreadStatus["exceptionCaught"] = 4] = "exceptionCaught";
})(NThreadStatus || (NThreadStatus = {}));
export class NThread {
    constructor(threadPool, state, initialStack, executeMode) {
        this.threadPool = threadPool;
        this.executeMode = executeMode;
        this.programStack = [];
        this.currentlyHeldSemaphors = [];
        this.programStack.push(state);
        this.currentProgramState = state;
        this.stack = initialStack;
    }
    /**
     * returns true if Thread exits
     */
    run(maxNumberOfSteps) {
        let numberOfSteps = 0;
        let stack = this.stack; // for performance reasons
        this.status = NThreadStatus.running;
        //@ts-ignore
        while (numberOfSteps < maxNumberOfSteps && this.status != NThreadStatus.exited) {
            this.status = NThreadStatus.running;
            // For performance reasons: store all necessary data in local variables
            let currentProgramState = this.currentProgramState;
            let stepIndex = currentProgramState.stepIndex;
            let currentStepList = currentProgramState.currentStepList;
            let stackBase = currentProgramState.stackBase;
            let helper = currentProgramState.program.helper;
            while (numberOfSteps < maxNumberOfSteps && this.status == NThreadStatus.running) {
                let step = currentStepList[stepIndex];
                stepIndex = step.run(stack, stackBase, helper, this);
                numberOfSteps++;
            }
            currentProgramState.stepIndex = stepIndex;
            // this currentProgram might by now not be the same as before this inner while-loop
            // because callMethod or returnFromMethod may have been called since from within 
            // step.run
        }
        return this.status;
    }
    throwException(exception) {
        let className = exception.__class.identifier;
        let catchingProgramState = null;
        let stackTrace = [];
        do {
            let ps = this.programStack[this.programStack.length - 1];
            for (let exInfo of ps.exceptionInfoList) {
                if (exInfo.types.indexOf(className) >= 0) {
                    catchingProgramState = ps;
                    stackTrace.push(Object.assign(ps));
                    ps.stepIndex = exInfo.stepIndex;
                    this.stack.splice(exInfo.stackSize, this.stack.length - exInfo.stackSize);
                    this.stack.push(exception);
                    this.status = NThreadStatus.exceptionCaught;
                    break;
                }
                else {
                    stackTrace.push(ps);
                    this.programStack.pop();
                }
            }
        } while (this.programStack.length > 0);
        if (this.programStack.length == 0) {
            this.stackTrace = stackTrace;
            this.exception = exception;
            this.status = NThreadStatus.exitedWithException;
        }
    }
    beginCatchExceptions(exceptionInfo) {
        exceptionInfo.stackSize = this.stack.length;
        this.currentProgramState.exceptionInfoList.push(exceptionInfo);
    }
    endCatchExceptions() {
        this.currentProgramState.exceptionInfoList.pop();
    }
    aquireSemaphor(semaphor) {
        if (!semaphor.aquire(this)) {
            this.status = NThreadStatus.exited;
        }
    }
    returnFromMethod(returnValue) {
        while (this.stack.length > this.currentProgramState.stackBase) {
            this.stack.pop();
        }
        if (returnValue != null)
            this.stack.push(returnValue);
        this.programStack.pop();
        if (this.programStack.length > 0) {
            this.currentProgramState = this.programStack[this.programStack.length - 1];
        }
        else {
            this.status = NThreadStatus.exited;
        }
    }
    callMethod(program, callbackAfterFinished) {
        let state = {
            program: program,
            currentStepList: this.executeMode == NExecuteMode.singleSteps ? program.stepsSingle : program.stepsMultiple,
            stackBase: this.stack.length - program.numberOfParamters - program.numberOfLocalVariables,
            stepIndex: 0,
            callbackAfterFinished: callbackAfterFinished,
            exceptionInfoList: []
        };
        this.programStack.push(state);
        this.currentProgramState = state;
        this.status = NThreadStatus.callMethod;
    }
}
export var NExecuteMode;
(function (NExecuteMode) {
    NExecuteMode[NExecuteMode["singleSteps"] = 0] = "singleSteps";
    NExecuteMode[NExecuteMode["multipleSteps"] = 1] = "multipleSteps";
})(NExecuteMode || (NExecuteMode = {}));
;
export class NThreadPool {
    constructor() {
        this.runningThreads = [];
        this.currentThreadIndex = 0;
    }
    run(numberOfStepsMax) {
        let stepsPerThread = Math.ceil(numberOfStepsMax / this.runningThreads.length);
        let numberOfSteps = 0;
        if (this.runningThreads.length == 0)
            return;
        while (numberOfSteps < numberOfStepsMax) {
            let currentThread = this.runningThreads[this.currentThreadIndex];
            let status = currentThread.run(stepsPerThread);
            numberOfSteps += stepsPerThread;
            switch (status) {
                case NThreadStatus.exited:
                    for (let semaphor of currentThread.currentlyHeldSemaphors) {
                        semaphor.release(currentThread);
                    }
                    this.runningThreads.splice(this.currentThreadIndex, 1);
                    if (this.runningThreads.length == 0) {
                        return NThreadStatus.exited;
                    }
                    break;
                case NThreadStatus.exitedWithException:
                    // TODO: Print Exception
                    return NThreadStatus.exitedWithException;
            }
            this.currentThreadIndex++;
            if (this.currentThreadIndex >= this.runningThreads.length) {
                this.currentThreadIndex = 0;
            }
        }
        return NThreadStatus.running;
    }
    createThread(program, executeMode, initialStack = [], callbackAfterFinished) {
        let state = {
            program: program,
            currentStepList: executeMode == NExecuteMode.singleSteps ? program.stepsSingle : program.stepsMultiple,
            stepIndex: -1,
            stackBase: 0,
            callbackAfterFinished: callbackAfterFinished,
            exceptionInfoList: []
        };
        this.runningThreads.push(new NThread(this, state, initialStack, executeMode));
    }
    suspendThread(thread) {
        let index = this.runningThreads.indexOf(thread);
        if (index >= 0) {
            this.runningThreads.splice(index, 1);
            if (this.currentThreadIndex >= index) {
                this.currentThreadIndex--;
            }
        }
    }
    restoreThread(thread) {
        this.runningThreads.push(thread);
    }
}
export class NSemaphor {
    constructor(threadPool, capacity) {
        this.threadPool = threadPool;
        this.capacity = capacity;
        this.runningThreads = [];
        this.waitingThreads = [];
        this.counter = capacity;
    }
    aquire(thread) {
        if (this.counter > 0) {
            this.counter--;
            this.runningThreads.push(thread);
            thread.currentlyHeldSemaphors.push(this);
            return true;
        }
        else {
            this.threadPool.suspendThread(thread);
            this.waitingThreads.push(thread);
            return false;
        }
    }
    release(thread) {
        let index = this.runningThreads.indexOf(thread);
        if (index >= 0) {
            this.runningThreads.splice(index, 1);
            if (this.waitingThreads.length > 0) {
                this.threadPool.restoreThread(this.waitingThreads.shift());
            }
            else {
                this.counter++;
            }
        }
        else {
            // Error: Thread had no token!
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTlRocmVhZFBvb2wuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2xpZW50L25ld2NvbXBpbGVyL05UaHJlYWRQb29sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtCQSxJQUFLLGFBQWtGO0FBQXZGLFdBQUssYUFBYTtJQUFHLHVEQUFPLENBQUE7SUFBRSw2REFBVSxDQUFBO0lBQUUscURBQU0sQ0FBQTtJQUFFLCtFQUFtQixDQUFBO0lBQUUsdUVBQWUsQ0FBQTtBQUFBLENBQUMsRUFBbEYsYUFBYSxLQUFiLGFBQWEsUUFBcUU7QUFHdkYsTUFBTSxPQUFPLE9BQU87SUFhaEIsWUFBbUIsVUFBdUIsRUFBRSxLQUFvQixFQUM1RCxZQUFtQixFQUFTLFdBQXlCO1FBRHRDLGVBQVUsR0FBVixVQUFVLENBQWE7UUFDVixnQkFBVyxHQUFYLFdBQVcsQ0FBYztRQVp6RCxpQkFBWSxHQUFvQixFQUFFLENBQUM7UUFJbkMsMkJBQXNCLEdBQWdCLEVBQUUsQ0FBQztRQVNyQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNILEdBQUcsQ0FBQyxnQkFBd0I7UUFDeEIsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQywwQkFBMEI7UUFDbEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDO1FBRXBDLFlBQVk7UUFDWixPQUFNLGFBQWEsR0FBRyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLGFBQWEsQ0FBQyxNQUFNLEVBQUM7WUFDOUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDO1lB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Q0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDakMsT0FBTyxLQUFLLENBQUM7U0FDaEI7SUFDTCxDQUFDO0lBRUQsT0FBTyxDQUFDLE1BQWU7UUFDbkIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDaEQsSUFBSSxLQUFLLElBQUksQ0FBQyxFQUFFO1lBQ1osSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNoQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7YUFDOUQ7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQ2xCO1NBQ0o7YUFBTTtZQUNILDhCQUE4QjtTQUNqQztJQUNMLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5Qcm9ncmFtLCBOU3RlcCB9IGZyb20gXCIuL05Qcm9ncmFtLmpzXCI7XHJcbmltcG9ydCB7IE5SdW50aW1lT2JqZWN0IH0gZnJvbSBcIi4vTlJ1bnRpbWVPYmplY3QuanNcIjtcclxuXHJcbnR5cGUgTkV4Y2VwdGlvbkluZm8gPSB7XHJcbiAgICB0eXBlczogc3RyaW5nW10sXHJcbiAgICBzdGVwSW5kZXg6IG51bWJlciwgXHJcbiAgICBzdGFja1NpemU6IG51bWJlclxyXG59XHJcblxyXG50eXBlIE5Qcm9ncmFtU3RhdGUgPSB7XHJcbiAgICBwcm9ncmFtOiBOUHJvZ3JhbTtcclxuICAgIGN1cnJlbnRTdGVwTGlzdDogTlN0ZXBbXTsgICAvLyBMaW5rIHRvIHByb2dyYW0uc3RlcFNpbmdsZSBvciBwcm9ncmFtLnN0ZXBNdWx0aXBsZVxyXG4gICAgc3RlcEluZGV4OiBudW1iZXI7XHJcbiAgICBzdGFja0Jhc2U6IG51bWJlcjtcclxuICAgIGNhbGxiYWNrQWZ0ZXJGaW5pc2hlZD86ICh2YWx1ZTogYW55KSA9PiB2b2lkO1xyXG4gICAgZXhjZXB0aW9uSW5mb0xpc3Q6IE5FeGNlcHRpb25JbmZvW107XHJcbn1cclxuXHJcbmVudW0gTlRocmVhZFN0YXR1cyB7IHJ1bm5pbmcsIGNhbGxNZXRob2QsIGV4aXRlZCwgZXhpdGVkV2l0aEV4Y2VwdGlvbiwgZXhjZXB0aW9uQ2F1Z2h0fVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBOVGhyZWFkIHtcclxuICAgIHN0YWNrOiBhbnlbXTtcclxuICAgIHByb2dyYW1TdGFjazogTlByb2dyYW1TdGF0ZVtdID0gW107XHJcblxyXG4gICAgY3VycmVudFByb2dyYW1TdGF0ZTogTlByb2dyYW1TdGF0ZTsgIC8vIGFsc28gbGllcyBvbiB0b3Agb2YgcHJvZ3JhbVN0YWNrXHJcblxyXG4gICAgY3VycmVudGx5SGVsZFNlbWFwaG9yczogTlNlbWFwaG9yW10gPSBbXTtcclxuXHJcbiAgICBzdGF0dXM6IE5UaHJlYWRTdGF0dXM7XHJcblxyXG4gICAgZXhjZXB0aW9uOiBOUnVudGltZU9iamVjdDtcclxuICAgIHN0YWNrVHJhY2U6IE5Qcm9ncmFtU3RhdGVbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdGhyZWFkUG9vbDogTlRocmVhZFBvb2wsIHN0YXRlOiBOUHJvZ3JhbVN0YXRlLCBcclxuICAgICAgICBpbml0aWFsU3RhY2s6IGFueVtdLCBwdWJsaWMgZXhlY3V0ZU1vZGU6IE5FeGVjdXRlTW9kZSkge1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbVN0YWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb2dyYW1TdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBpbml0aWFsU3RhY2s7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgVGhyZWFkIGV4aXRzXHJcbiAgICAgKi9cclxuICAgIHJ1bihtYXhOdW1iZXJPZlN0ZXBzOiBudW1iZXIpOiBOVGhyZWFkU3RhdHVzIHtcclxuICAgICAgICBsZXQgbnVtYmVyT2ZTdGVwcyA9IDA7XHJcbiAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zdGFjazsgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IE5UaHJlYWRTdGF0dXMucnVubmluZztcclxuICAgICAgICBcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICB3aGlsZShudW1iZXJPZlN0ZXBzIDwgbWF4TnVtYmVyT2ZTdGVwcyAmJiB0aGlzLnN0YXR1cyAhPSBOVGhyZWFkU3RhdHVzLmV4aXRlZCl7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBOVGhyZWFkU3RhdHVzLnJ1bm5pbmc7XHJcbiAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IHN0b3JlIGFsbCBuZWNlc3NhcnkgZGF0YSBpbiBsb2NhbCB2YXJpYWJsZXNcclxuICAgICAgICBsZXQgY3VycmVudFByb2dyYW1TdGF0ZSA9IHRoaXMuY3VycmVudFByb2dyYW1TdGF0ZTtcclxuICAgICAgICBsZXQgc3RlcEluZGV4ID0gY3VycmVudFByb2dyYW1TdGF0ZS5zdGVwSW5kZXg7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRTdGVwTGlzdCA9IGN1cnJlbnRQcm9ncmFtU3RhdGUuY3VycmVudFN0ZXBMaXN0O1xyXG4gICAgICAgIGxldCBzdGFja0Jhc2UgPSBjdXJyZW50UHJvZ3JhbVN0YXRlLnN0YWNrQmFzZTtcclxuICAgICAgICBsZXQgaGVscGVyID0gY3VycmVudFByb2dyYW1TdGF0ZS5wcm9ncmFtLmhlbHBlcjtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlKG51bWJlck9mU3RlcHMgPCBtYXhOdW1iZXJPZlN0ZXBzICYmIHRoaXMuc3RhdHVzID09IE5UaHJlYWRTdGF0dXMucnVubmluZyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGN1cnJlbnRTdGVwTGlzdFtzdGVwSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgc3RlcEluZGV4ID0gc3RlcC5ydW4oc3RhY2ssIHN0YWNrQmFzZSwgaGVscGVyLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIG51bWJlck9mU3RlcHMrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3VycmVudFByb2dyYW1TdGF0ZS5zdGVwSW5kZXggPSBzdGVwSW5kZXg7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgY3VycmVudFByb2dyYW0gbWlnaHQgYnkgbm93IG5vdCBiZSB0aGUgc2FtZSBhcyBiZWZvcmUgdGhpcyBpbm5lciB3aGlsZS1sb29wXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgY2FsbE1ldGhvZCBvciByZXR1cm5Gcm9tTWV0aG9kIG1heSBoYXZlIGJlZW4gY2FsbGVkIHNpbmNlIGZyb20gd2l0aGluIFxyXG4gICAgICAgICAgICAvLyBzdGVwLnJ1blxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93RXhjZXB0aW9uKGV4Y2VwdGlvbjogTlJ1bnRpbWVPYmplY3Qpe1xyXG4gICAgICAgIGxldCBjbGFzc05hbWUgPSBleGNlcHRpb24uX19jbGFzcy5pZGVudGlmaWVyO1xyXG4gICAgICAgIGxldCBjYXRjaGluZ1Byb2dyYW1TdGF0ZTogTlByb2dyYW1TdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHN0YWNrVHJhY2U6IE5Qcm9ncmFtU3RhdGVbXSA9IFtdO1xyXG4gICAgICAgIGRvIHtcclxuXHJcbiAgICAgICAgICAgIGxldCBwcyA9IHRoaXMucHJvZ3JhbVN0YWNrW3RoaXMucHJvZ3JhbVN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBmb3IobGV0IGV4SW5mbyBvZiBwcy5leGNlcHRpb25JbmZvTGlzdCl7XHJcbiAgICAgICAgICAgICAgICBpZihleEluZm8udHlwZXMuaW5kZXhPZihjbGFzc05hbWUpID49IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoaW5nUHJvZ3JhbVN0YXRlID0gcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tUcmFjZS5wdXNoKE9iamVjdC5hc3NpZ24ocHMpKTtcclxuICAgICAgICAgICAgICAgICAgICBwcy5zdGVwSW5kZXggPSBleEluZm8uc3RlcEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2suc3BsaWNlKGV4SW5mby5zdGFja1NpemUsIHRoaXMuc3RhY2subGVuZ3RoIC0gZXhJbmZvLnN0YWNrU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGV4Y2VwdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBOVGhyZWFkU3RhdHVzLmV4Y2VwdGlvbkNhdWdodDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tUcmFjZS5wdXNoKHBzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2dyYW1TdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IHdoaWxlKHRoaXMucHJvZ3JhbVN0YWNrLmxlbmd0aCA+IDApXHJcblxyXG4gICAgICAgIGlmKHRoaXMucHJvZ3JhbVN0YWNrLmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgdGhpcy5zdGFja1RyYWNlID0gc3RhY2tUcmFjZTtcclxuICAgICAgICAgICAgdGhpcy5leGNlcHRpb24gPSBleGNlcHRpb247XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gTlRocmVhZFN0YXR1cy5leGl0ZWRXaXRoRXhjZXB0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBiZWdpbkNhdGNoRXhjZXB0aW9ucyhleGNlcHRpb25JbmZvOiBORXhjZXB0aW9uSW5mbyl7XHJcbiAgICAgICAgZXhjZXB0aW9uSW5mby5zdGFja1NpemUgPSB0aGlzLnN0YWNrLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9ncmFtU3RhdGUuZXhjZXB0aW9uSW5mb0xpc3QucHVzaChleGNlcHRpb25JbmZvKTtcclxuICAgIH1cclxuXHJcbiAgICBlbmRDYXRjaEV4Y2VwdGlvbnMoKXtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9ncmFtU3RhdGUuZXhjZXB0aW9uSW5mb0xpc3QucG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXF1aXJlU2VtYXBob3Ioc2VtYXBob3I6IE5TZW1hcGhvcil7XHJcbiAgICAgICAgaWYoIXNlbWFwaG9yLmFxdWlyZSh0aGlzKSl7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gTlRocmVhZFN0YXR1cy5leGl0ZWQ7XHJcbiAgICAgICAgfSBcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm5Gcm9tTWV0aG9kKHJldHVyblZhbHVlOiBhbnkpe1xyXG4gICAgICAgIHdoaWxlKHRoaXMuc3RhY2subGVuZ3RoID4gdGhpcy5jdXJyZW50UHJvZ3JhbVN0YXRlLnN0YWNrQmFzZSl7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHJldHVyblZhbHVlICE9IG51bGwpIHRoaXMuc3RhY2sucHVzaChyZXR1cm5WYWx1ZSk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtU3RhY2sucG9wKCk7XHJcbiAgICAgICAgaWYodGhpcy5wcm9ncmFtU3RhY2subGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb2dyYW1TdGF0ZSA9IHRoaXMucHJvZ3JhbVN0YWNrW3RoaXMucHJvZ3JhbVN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gTlRocmVhZFN0YXR1cy5leGl0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNhbGxNZXRob2QocHJvZ3JhbTogTlByb2dyYW0sIGNhbGxiYWNrQWZ0ZXJGaW5pc2hlZD86ICh2YWx1ZTogYW55KSA9PiB2b2lkKXtcclxuICAgICAgICBsZXQgc3RhdGU6IE5Qcm9ncmFtU3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHByb2dyYW06IHByb2dyYW0sXHJcbiAgICAgICAgICAgIGN1cnJlbnRTdGVwTGlzdDogdGhpcy5leGVjdXRlTW9kZSA9PSBORXhlY3V0ZU1vZGUuc2luZ2xlU3RlcHMgPyBwcm9ncmFtLnN0ZXBzU2luZ2xlIDogcHJvZ3JhbS5zdGVwc011bHRpcGxlLFxyXG4gICAgICAgICAgICBzdGFja0Jhc2U6IHRoaXMuc3RhY2subGVuZ3RoIC0gcHJvZ3JhbS5udW1iZXJPZlBhcmFtdGVycyAtIHByb2dyYW0ubnVtYmVyT2ZMb2NhbFZhcmlhYmxlcyxcclxuICAgICAgICAgICAgc3RlcEluZGV4OiAwLFxyXG4gICAgICAgICAgICBjYWxsYmFja0FmdGVyRmluaXNoZWQ6IGNhbGxiYWNrQWZ0ZXJGaW5pc2hlZCxcclxuICAgICAgICAgICAgZXhjZXB0aW9uSW5mb0xpc3Q6IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJvZ3JhbVN0YWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb2dyYW1TdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gTlRocmVhZFN0YXR1cy5jYWxsTWV0aG9kO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBORXhlY3V0ZU1vZGUgeyBzaW5nbGVTdGVwcywgbXVsdGlwbGVTdGVwc307XHJcblxyXG5leHBvcnQgY2xhc3MgTlRocmVhZFBvb2wge1xyXG4gICAgcnVubmluZ1RocmVhZHM6IE5UaHJlYWRbXSA9IFtdO1xyXG4gICAgY3VycmVudFRocmVhZEluZGV4OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHJ1bihudW1iZXJPZlN0ZXBzTWF4OiBudW1iZXIpOiBOVGhyZWFkU3RhdHVzIHtcclxuICAgICAgICBsZXQgc3RlcHNQZXJUaHJlYWQgPSBNYXRoLmNlaWwobnVtYmVyT2ZTdGVwc01heC90aGlzLnJ1bm5pbmdUaHJlYWRzLmxlbmd0aCk7XHJcbiAgICAgICAgbGV0IG51bWJlck9mU3RlcHMgPSAwO1xyXG4gICAgICAgIGlmKHRoaXMucnVubmluZ1RocmVhZHMubGVuZ3RoID09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgd2hpbGUobnVtYmVyT2ZTdGVwcyA8IG51bWJlck9mU3RlcHNNYXgpe1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFRocmVhZCA9IHRoaXMucnVubmluZ1RocmVhZHNbdGhpcy5jdXJyZW50VGhyZWFkSW5kZXhdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IHN0YXR1cyA9IGN1cnJlbnRUaHJlYWQucnVuKHN0ZXBzUGVyVGhyZWFkKTtcclxuICAgICAgICAgICAgbnVtYmVyT2ZTdGVwcyArPSBzdGVwc1BlclRocmVhZDtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaChzdGF0dXMpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBOVGhyZWFkU3RhdHVzLmV4aXRlZDpcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHNlbWFwaG9yIG9mIGN1cnJlbnRUaHJlYWQuY3VycmVudGx5SGVsZFNlbWFwaG9ycyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbWFwaG9yLnJlbGVhc2UoY3VycmVudFRocmVhZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmdUaHJlYWRzLnNwbGljZSh0aGlzLmN1cnJlbnRUaHJlYWRJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5ydW5uaW5nVGhyZWFkcy5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOVGhyZWFkU3RhdHVzLmV4aXRlZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE5UaHJlYWRTdGF0dXMuZXhpdGVkV2l0aEV4Y2VwdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBQcmludCBFeGNlcHRpb25cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTlRocmVhZFN0YXR1cy5leGl0ZWRXaXRoRXhjZXB0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaHJlYWRJbmRleCsrO1xyXG4gICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRUaHJlYWRJbmRleCA+PSB0aGlzLnJ1bm5pbmdUaHJlYWRzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUaHJlYWRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBOVGhyZWFkU3RhdHVzLnJ1bm5pbmc7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVRocmVhZChwcm9ncmFtOiBOUHJvZ3JhbSwgZXhlY3V0ZU1vZGU6IE5FeGVjdXRlTW9kZSwgaW5pdGlhbFN0YWNrOiBhbnlbXSA9IFtdLCBjYWxsYmFja0FmdGVyRmluaXNoZWQ/OiAodmFsdWU6IGFueSkgPT4gdm9pZCl7XHJcbiAgICAgICAgbGV0IHN0YXRlOiBOUHJvZ3JhbVN0YXRlID0ge1xyXG4gICAgICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxyXG4gICAgICAgICAgICBjdXJyZW50U3RlcExpc3Q6IGV4ZWN1dGVNb2RlID09IE5FeGVjdXRlTW9kZS5zaW5nbGVTdGVwcyA/IHByb2dyYW0uc3RlcHNTaW5nbGUgOiBwcm9ncmFtLnN0ZXBzTXVsdGlwbGUsXHJcbiAgICAgICAgICAgIHN0ZXBJbmRleDogLTEsXHJcbiAgICAgICAgICAgIHN0YWNrQmFzZTogMCxcclxuICAgICAgICAgICAgY2FsbGJhY2tBZnRlckZpbmlzaGVkOiBjYWxsYmFja0FmdGVyRmluaXNoZWQsXHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkluZm9MaXN0OiBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnJ1bm5pbmdUaHJlYWRzLnB1c2gobmV3IE5UaHJlYWQodGhpcywgc3RhdGUsIGluaXRpYWxTdGFjaywgZXhlY3V0ZU1vZGUpKTtcclxuICAgIH1cclxuXHJcbiAgICBzdXNwZW5kVGhyZWFkKHRocmVhZDogTlRocmVhZCkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucnVubmluZ1RocmVhZHMuaW5kZXhPZih0aHJlYWQpO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucnVubmluZ1RocmVhZHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFRocmVhZEluZGV4ID49IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUaHJlYWRJbmRleC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlc3RvcmVUaHJlYWQodGhyZWFkOiBOVGhyZWFkKSB7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nVGhyZWFkcy5wdXNoKHRocmVhZCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTlNlbWFwaG9yIHtcclxuICAgIGNvdW50ZXI6IG51bWJlcjsgICAgICAgIC8vIE51bWJlciBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIHRva2Vuc1xyXG5cclxuICAgIHJ1bm5pbmdUaHJlYWRzOiBOVGhyZWFkW10gPSBbXTtcclxuICAgIHdhaXRpbmdUaHJlYWRzOiBOVGhyZWFkW10gPSBbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRocmVhZFBvb2w6IE5UaHJlYWRQb29sLCBwcml2YXRlIGNhcGFjaXR5OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmNvdW50ZXIgPSBjYXBhY2l0eTtcclxuICAgIH1cclxuXHJcbiAgICBhcXVpcmUodGhyZWFkOiBOVGhyZWFkKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnRlciA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb3VudGVyLS07XHJcbiAgICAgICAgICAgIHRoaXMucnVubmluZ1RocmVhZHMucHVzaCh0aHJlYWQpO1xyXG4gICAgICAgICAgICB0aHJlYWQuY3VycmVudGx5SGVsZFNlbWFwaG9ycy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRocmVhZFBvb2wuc3VzcGVuZFRocmVhZCh0aHJlYWQpO1xyXG4gICAgICAgICAgICB0aGlzLndhaXRpbmdUaHJlYWRzLnB1c2godGhyZWFkKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWxlYXNlKHRocmVhZDogTlRocmVhZCkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucnVubmluZ1RocmVhZHMuaW5kZXhPZih0aHJlYWQpO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucnVubmluZ1RocmVhZHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMud2FpdGluZ1RocmVhZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aHJlYWRQb29sLnJlc3RvcmVUaHJlYWQodGhpcy53YWl0aW5nVGhyZWFkcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnRlcisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRXJyb3I6IFRocmVhZCBoYWQgbm8gdG9rZW4hXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59Il19